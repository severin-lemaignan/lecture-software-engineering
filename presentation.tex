%!TEX program = xelatex

\documentclass[compress]{beamer}
%--------------------------------------------------------------------------
% Common packages
%--------------------------------------------------------------------------

\definecolor{links}{HTML}{663000}
\hypersetup{colorlinks,linkcolor=,urlcolor=links}

\usepackage[english]{babel}
\usepackage{pgfpages} % required for notes on second screen
\usepackage{graphicx}

\usepackage{hyperref}
    
\usepackage{pdfpcnotes}

\usepackage{gitdags}

\usepackage{multicol}

\usepackage{tabularx,ragged2e}
\usepackage{booktabs}

\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}


\usetheme{hri}

% Display the navigation bullet even without subsections
\usepackage{remreset}% tiny package containing just the \@removefromreset command
\makeatletter
\@removefromreset{subsection}{section}
\makeatother
\setcounter{subsection}{1}

\makeatletter
\let\beamer@writeslidentry@miniframeson=\beamer@writeslidentry
\def\beamer@writeslidentry@miniframesoff{%
  \expandafter\beamer@ifempty\expandafter{\beamer@framestartpage}{}% does not happen normally
  {%else
    % removed \addtocontents commands
    \clearpage\beamer@notesactions%
  }
}
\newcommand*{\miniframeson}{\let\beamer@writeslidentry=\beamer@writeslidentry@miniframeson}
\newcommand*{\miniframesoff}{\let\beamer@writeslidentry=\beamer@writeslidentry@miniframesoff}
\makeatother



\tikzset{temporal/.code args={<#1>#2#3#4}{%
          \temporal<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}}{\pgfkeysalso{#4}} % \pgfkeysalso doesn't change the path
}}

\newcommand{\source}[2]{{\tiny\it Source: \href{#1}{#2}}}

\usepackage[normalem]{ulem}

\usepackage{tikz}
\usetikzlibrary{intersections,arrows,shapes,calc,mindmap,backgrounds,positioning,svg.path}

\tikzset{box/.style={
            draw, 
            fill=blue!20,
            fill opacity=0.8,
            thick,
            inner sep=0pt,
            minimum size=1cm,
            transform shape
        },
        finalbox/.style={
            draw, 
            fill=orange,
            fill opacity=0.8,
            thick,
            inner sep=0pt,
            minimum size=1cm,
            transform shape
        },
        dot/.style={
            draw,
            circle,
            fill=red!20,
            inner sep=0pt,
            minimum size=1cm,
            transform shape
        },
        axis/.style={
            thick,
            gray,
            font=\small},
        every to/.style={
            >=latex,
            dashed,
            thick
        }
    }


\graphicspath{{figs/}}

\title{Software Engineering}
\subtitle{FARSCOPE workshops}
\date{}
\author{Séverin Lemaignan}
\institute{Bristol Robotics Lab\\{\bf University of the West of
England/University of Bristol}}

\begin{document}

\licenseframe{github.com/severin-lemaignan/lecture-software-engineering}

\maketitle

\miniframesoff

\begin{frame}{Today's objectives}

    \only<1-12>{
    At the end of the day, you should know more about:

    \begin{itemize}
        \item<+-> \hyperlink{codeversioning}{code versioning with git}
        \item<+-> What does ``compiling code'' \emph{really} means (but you
            remember from last time, right?)
        \item<+-> The difference between a \sh{dll} and a \sh{lib}
        \item<+-> \hyperlink{libraries}{(and what are \sh{dll}s)}
        \item<+-> \hyperlink{cmake}{What is {\bf CMake}}
        \item<+-> \hyperlink{deb}{What is a \texttt{deb} package and how to create one?}
        \item<+-> How to write and distribute a Python package
        \item<+-> How to organise your code on your hard-drive
        \item<+-> \hyperlink{FHS}{What \emph{Filesystem Standard Hierarchy} means}
        \item<+-> \hyperlink{markdown}{What is markdown}
        \item<+-> \hyperlink{licenses}{The differences between the GPL, MIT, BSD,... licenses}
        \item<+-> \hyperlink{advancedgit}{More git: code sharing, conflict resolution, branching}
    \end{itemize}

    }
    \only<13>{

        Looks daunting?

        \begin{itemize}
            \item one of the main challenges of software engineering is the
                lack of 'structured' approach to it. {\bf Mostly know-how!}

            \item today's aim is to give you a broad overview + get the key
                terminology, so that you can successfully navigate this space

            \item experience (eg, Google + stackoverflow, mainly) will do the rest

            \item We will focus on Linux, as most of the concepts are more
                mature and better enforced in this developer friendly
                environment. However, to a large extend, {\bf the same
                principles apply to any operating system \& programming
                environment}

        \end{itemize}

    }
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Git}

\imageframe[color=black, scale=0.95]{first_mention_git}
\imageframe[color=black, scale=0.95]{windows_on_git_announcement}

\imageframe[color=black, caption=These directories are git repositories]{windows-explorer/explorer-base}
\imageframe[color=black, caption=They look boringly normal]{windows-explorer/explorer-gitrepo}

\begin{frame}[plain]
    A few roundtrips later with teammates...
\end{frame}

\imageframe{zipfiles}
\imageframe{dropbox_zipfiles}
\imageframe{dropbox_zipfiles_devil}

{
    \fullbackground{../figs/facebook-wall.png}
    \begin{frame}[plain]{}
        \only<2>{
            \begin{center}
                \includegraphics[width=\linewidth]{devil}
            \end{center}
        }
    \end{frame}
}


\begin{frame}{}
    \begin{center}
        \textbf{We can do better!}
    \end{center}
    \pause

    \textbf{git} is essentially about recording the history of files
    \pause

    (and who did what)
    \pause

    (and sharing as well -- we'll talk about it tomorrow)
\end{frame}

\section{Code Versioning}

\begin{frame}[label=codeversioning]{Why versioning?}

    \begin{itemize}
        \item The history of your development/document
        \item Compare the current code with an older version
        \item Roll-back to previous versions (think 'undo on steroids')
        \item Experiment without losing anything
        \item Trace who did what (at the level of the line of code)
        \item Annotate your workflow (important milestones, etc)
        \item Avoid catastrophes!
    \end{itemize}
\end{frame}

\begin{frame}{Atomic commits}

    The single most important concept (because it requires to think about
    development/writing in terms of {\bf functional units}):

    \highlightbox{Atomic commit}

    \only<1>{
        A (typically small) commit that represent a {\bf single, coherent \&
    complete} functional change.
    }
    \only<2>{
    \begin{itemize}
        \item Easy to understand the change
        \item Debugging made easy (\texttt{git bisect})
        \item Collaboration made easy (less, smaller conflict)
        \item Easy to write a useful commit message
    \end{itemize}
    }

\end{frame}

\begin{frame}[fragile]{}

\centering

\begin{tikzpicture}[
    >=latex,
    every edge/.style={draw,thick,hriSec3},
    file/.style={align=left, inner sep=1pt,font=\scriptsize\tt}
]

\node at (-2, 1.5)[file,temporal=<4>{red}{black}{white}] (file1) {\sout{main.cpp}};
\node [file,temporal=<4>{red}{black}{white},below=0.0 of file1.south east,anchor=north east] (file2) {src/main.cpp};
\node [file,temporal=<2>{red}{black}{white},below=0.0 of file2.south east, anchor=north east] (file3) {src/position.cpp};
\node [file,temporal=<2>{red}{black}{white},below=0.0 of file3.south east,anchor=north east] (file4) {src/position.hpp};
\node [file,temporal=<3>{red}{black}{white},below=0.0 of file4.south east,anchor=north east] (file5) {share/model.csv};


    \onslide<2>{
        \gitDAG[grow right sep = 2em]{
            A;
        };

        \gitbranch
        {master}
        {above=of A}
        {A}

        \gitHEAD
        {above=of master}
        {master}


    \path[draw] (file3.east) edge [->, bend left] (A);
    \path[draw] (file4.east) edge [->, bend left] (A);

    }
    \onslide<3>{
        \gitDAG[grow right sep = 2em]{
            A -- B;
        };

        \gitbranch
        {master}
        {above=of B}
        {B}

        \gitHEAD
        {above=of master}
        {master}

        \path[draw] (file5.east) edge [->, bend left,hriSec2] (B);
    }

    \onslide<4->{
        \gitDAG[grow right sep = 2em]{
            A -- B -- C;
        };

        \gitbranch
        {master}     % node name and text 
        {above=of C} % node placement
        {C}          % target

        \gitHEAD
        {above=of master} % node placement
        {master}          % target

        \path[draw] (file1.east) edge [->, bend left,hriSec1Comp] (C);
        \path[draw] (file2.east) edge [->, bend left,hriSec1Comp] (C);
    }

\end{tikzpicture}

\vspace{3em}
\small
\only<2>{
\texttt{git add src/position.*}\\
\texttt{git commit -m"Fix computation of position (float->double)"}
}
\only<3>{
\texttt{git add share/model.csv}\\
\texttt{git commit -m"Re-trained model with 52 more participants"}
}
\uncover<4>{
\texttt{git rm main.cpp}\\
\texttt{git add src/main.cpp}\\
\texttt{git commit -m"Move main.cpp to src/"}
}

\end{frame}

\begin{frame}[fragile]{Log}
\begin{shcode}
$ git log

commit fa009cd7fca05b0b61170b20cf76a5f72b8843c2
Author: Severin Lemaignan <severin.lemaignan@brl.ac.uk>
Date:   Tue Nov 24 16:48:22 2020 +0000

    Move main.cpp to src/

commit aff81119459d9193c09effef1c150c4f7eac08dc
Author: Severin Lemaignan <severin.lemaignan@brl.ac.uk>
Date:   Tue Nov 24 16:48:02 2020 +0000

    Re-trained model with 52 more participants

commit 4113b9b6e6bbc8de532ad90153e0059cb5819de7
Author: Severin Lemaignan <severin.lemaignan@brl.ac.uk>
Date:   Tue Nov 24 16:47:46 2020 +0000

    Fix computation of position (float->double)
\end{shcode}


\end{frame}

\begin{frame}{}

\centering

\begin{tikzpicture}
        \gitDAG[grow right sep = 2em]{
            4113b9 -- aff811 -- fa009c;
        };

        \gitbranch
        {master}     % node name and text 
        {above=of fa009c} % node placement
        {fa009c}          % target

        \gitHEAD
        {above=of master} % node placement
        {master}          % target

\end{tikzpicture}

\end{frame}

\begin{frame}{The staging area}
    \centering
    \only<1>{
        But why do we have to manually tell Git what files to add or remove?
    }
    \only<2>{
        No ``commit all changes'' by default {\tiny (well, you
        can, actually...)}\\
        $\Rightarrow$ Help thinking in terms of atomic commits!
    }
    \only<3->{
        Preparing a commit consists in filling the {\bf staging area} (or
        {\bf index}) with the list of changes:

        \begin{tikzpicture}[
                >=latex,
                every edge/.style={draw,thick,hriSec3},
                file/.style={align=left, inner sep=1pt,font=\scriptsize\tt}
            ]

            \node at (-3.5, 2)[file,red] (file1) {\sout{main.cpp}};
            \node [file,red,below=0.0 of file1.south east,anchor=north east] (file2) {src/main.cpp};
            \node [file,temporal=<3>{red}{black}{white},below=0.0 of file2.south east, anchor=north east] (file3) {src/position.cpp};
            \node [file,temporal=<3>{red}{black}{white},below=0.0 of file3.south east,anchor=north east] (file4) {src/position.hpp};
            \node [file,red,below=0.0 of file4.south east,anchor=north east] (file5) {share/model.csv};


            \node[gitSA,] (stagingarea) at (-2.5,3) {staging area};

            \onslide<3>{
                \gitDAG[grow right sep = 2em]{
                    154ce2 -- f327ba;
                };

                \gitbranch
                {master}     % node name and text 
                {above=of f327ba} % node placement
                {f327ba}          % target

                \gitHEAD
                {above=of master} % node placement
                {master}          % target



                \path[draw] (file3.east) edge [->, bend right,hriSec1Comp] (stagingarea);
                \path[draw] (file4.east) edge [->, bend right,hriSec1Comp] (stagingarea);

            }
            \onslide<4>{
                \gitDAG[grow right sep = 2em]{
                    154ce2 -- f327ba -- 4113b9;
                };

                \gitbranch
                {master}     % node name and text 
                {above=of 4113b9} % node placement
                {4113b9}          % target

                \gitHEAD
                {above=of master} % node placement
                {master}          % target

                \node[highlighted commit] at (4113b9) {\phantom{4113b9}};
                \draw[resetarrows] ([xshift=-1em,yshift=-1em]stagingarea.east) to[bend
                left] (4113b9.north west);

            }



        \end{tikzpicture}


        \only<3>{
            \texttt{git add}, \texttt{git rm}\\
            \texttt{git mv}\\
            \texttt{git add -p}\\
            ...\\
        }
        \only<4>{
            ~\\
            \texttt{git commit}\\
            ~\\
            ~\\
        }


    }
\end{frame}

\begin{frame}[fragile]{To summarize...}

\begin{onlyenv}<1>

The first time:
\begin{shcode}
$ mkdir my_repo && cd my_repo
$ git init
\end{shcode}
    Then:
\begin{shcode}
# make some changes...
$ git add <files>
$ git commit -m"<commit message>"
# make some changes...
$ git add <files>
$ git commit -m"<other commit message>"
# That's it!
\end{shcode}

\end{onlyenv}
\begin{onlyenv}<2>
 Plenty of tools to help with that, including GUI (one of the best one is the one that comes with VSCode).

My two favourite ones: \texttt{tig} and \texttt{gitk}

\begin{shcode}
$ sudo apt install tig gitk
$ gitk &
$ tig status
\end{shcode}
\end{onlyenv}

\end{frame}

\begin{frame}[plain]{}
    \begin{center}
        \Large
        {\bf Exercise}: turn your {\tt robomaze} pathfinder into a git repo, and commit the C++ and Python A* as two commits.
    \end{center}

\end{frame}

\begin{frame}{What should be tracked?}

    Short answer: \textbf{everything you care about in your project}
    \pause

    (you can left out temporary files, automatically generated files, etc
    $\rightarrow$ \texttt{.gitignore})

    \pause

    However, versioning is \textbf{less useful for binary files}: 

    \begin{itemize}
        \item no line-by-line tracking of changes
        \item every single change creates a whole copy: repo size might grow
            quickly!
    \end{itemize}

    Binary files include images, archives (zip files), \textbf{PDF},
    \textbf{most office document (docx/xlsx/pptx)}
    \pause

    For documents, you might want to consider alternative like
    \href{https://en.wikipedia.org/wiki/Markdown\#Example}{markdown}.

\end{frame}

\imageframe[color=black, caption=What should I track here?]{windows-explorer/explorer-gitrepo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section[Compilation]{Building code}

\begin{frame}[fragile]{Compiling code in C++}

\begin{cppcode}
/*
 * Everyone's favourite: "Hello, World!"
 */

#include <iostream>

using namespace std;

int main(void)
{
    cout << "Hello, World!" << endl;
    return 0;
}
\end{cppcode}

\pause

\begin{shcode}
$ g++ hello.cpp -ohello
\end{shcode}

\pause 

\begin{shcode}
$ ./hello
Hello, World!
\end{shcode}

\end{frame}


\begin{frame}{Compiling code in C++: the main stages}

    \begin{enumerate}
        \item Pre-processing
        \item Compilation
        \item Assembly
        \item Linking
    \end{enumerate}

These four steps are transparently performed one after the other by your
    favourite compiler.

\end{frame}

\begin{frame}[fragile]{Compiling code in C++: Pre-processing}


\begin{cppcode}
/*
 * "Hello, World!": A classic.
 */

#include <iostream>

using namespace std;

int main(void)
{
    cout << "Hello, World!" << endl;
    return 0;
}
\end{cppcode}

Pre-processor \emph{directives} start with \cpp{#}

$\rightarrow$ \cpp{#include <iostream>} is replaced by the content of that file.

\end{frame}

\begin{frame}[fragile]{Compiling code in C++: Compilation}

\begin{shcode}
$ g++ -S hello.cpp
\end{shcode}


\begin{asmcode}
main:
.LFB1493:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	leaq	.LC0(%rip), %rsi
	leaq	_ZSt4cout(%rip), %rdi
	call	_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@PLT
	movq	%rax, %rdx
	movq	_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@GOTPCREL(%rip), %rax
	movq	%rax, %rsi
	movq	%rdx, %rdi
	call	_ZNSolsEPFRSoS_E@PLT
\end{asmcode}
\end{frame}

\begin{frame}[fragile]{Compiling code in C++: Assembly}

\begin{shcode}
$ g++ -s hello.cpp
$ hexdump a.out
0000000 457f 464c 0102 0001 0000 0000 0000 0000
0000010 0003 003e 0001 0000 07b0 0000 0000 0000
0000020 0040 0000 0000 0000 1128 0000 0000 0000
0000030 0000 0000 0040 0038 0009 0040 001b 001a
0000040 0006 0000 0005 0000 0040 0000 0000 0000
0000050 0040 0000 0000 0000 0040 0000 0000 0000
0000060 01f8 0000 0000 0000 01f8 0000 0000 0000
0000070 0008 0000 0000 0000 0003 0000 0004 0000
0000080 0238 0000 0000 0000 0238 0000 0000 0000
0000090 0238 0000 0000 0000 001c 0000 0000 0000
00000a0 001c 0000 0000 0000 0001 0000 0000 0000
00000b0 0001 0000 0005 0000 0000 0000 0000 0000
00000c0 0000 0000 0000 0000 0000 0000 0000 0000
00000d0 0b78 0000 0000 0000 0b78 0000 0000 0000
00000e0 0000 0020 0000 0000 0001 0000 0006 0000
...
\end{shcode}
\end{frame}

\begin{frame}[fragile]{Compiling code in C++: Linking}

The linker copies (and re-arrange) the machine code of the static dependencies
(\emph{static libraries}) into the executable.

That's what the \texttt{-l} flag is used for:

\begin{shcode}
$ g++ cool_app.cpp -ocool_app -lcv_core -lcv_highgui -lcv_videoproc
\end{shcode}

\end{frame}

%\begin{frame}{Compiled vs Not compiled}
%
%    Multiple \textbf{execution models}:
%
%    \begin{itemize}
%        \item<1-> Compiled languages (eg C, C++, Ada...)
%        \item<2-> Interpreted languages (eg: ...?)
%        \item<3-> $\rightarrow$ most 'interpreted languages' are actually 'JITed'
%    \end{itemize}
%
%    \onslide<3> {
%
%    \textbf{Just-In-Time} compilation: the interpreter generates an efficient
%    \textbf{intermediate representation} (commonly called \textbf{bytecode})
%    that is executed (and often stored).
%
%    Very common execution model: Python, C\#, Javascript...
%
%    }
%\end{frame}

\begin{frame}{Modern compiler infrastructure}
    \begin{center}
        \resizebox{\linewidth}{!}{
            \begin{tikzpicture}[>=latex,font=\footnotesize,node distance=2cm]

                \node[rectangle,draw] (fe) {Front-end};
                \node[rectangle,draw,fill=hriSec2, right of=fe] (ir) {IR};
                \node[rectangle,draw, right of=ir] (be) {Back-end};
                \draw[->] (fe) -- (ir) -- (be);
            \end{tikzpicture}
        }
    \end{center}

    For instance, LLVM has a front-end for C/C++ called \texttt{clang} and has
    many backends (like \texttt{emscripten} to create the new \texttt{wasm}
    binaries for consumption by the web browsers)
\end{frame}

\begin{frame}[label=libraries]{Libraries}

    A library is a collection of pre-compiled functions that might get called by
    an executable. \emph{Libraries are not executable} by themselves.

    \begin{exampleblock}{Why libraries?}
        \begin{itemize}
            \item to modularise your code
            \item to make it easier to reuse
        \end{itemize}
    \end{exampleblock}

    \pause

    Two main kinds:

    \begin{itemize}
        \item Static libraries, whose code is \emph{copied} into the executable
            by the linker. Extensions: \texttt{.a}, \texttt{.lib}
        \item Dynamic libraries, whose code is \emph{loaded by the operating
            system} at runtime. They are also called \emph{shared libraries}.
            Extensions: \texttt{.so}, \texttt{.dll}, \texttt{.dylib}
    \end{itemize}

\end{frame}

\begin{frame}{Static vs Dynamic libraries}

    \only<1>{
    \begin{center}
        \Large
    Take 5 min and try to list 2 advantages for the static libraries
    on one hand, and the dynamic libraries on the other hand.
    \end{center}
    }

    \onslide<2-> {

    \textbf{Advantages of static libraries}:
    \begin{itemize}
        \item application can be certain that all its libraries are present
        \item libraries are the correct version {\small (on Linux, distributions
            and package managers handle that for dynamic libraries)}
        \item single executable: simpler distribution and installation
        \item only need to copy (and load into memory) the parts that are needed
    \end{itemize}

}
    \onslide<3->{
    \textbf{Advantages of dynamic libraries}:
    \begin{itemize}
        \item executables smaller because no need to copy the libraries' code
        \item prevent redundant code in the system
        \item allows the libraries to be easily updated to fix bugs and security flaws
            without updating each of the applications
    \end{itemize}
}
\end{frame}

\begin{frame}[fragile]{Two tools to explore libraries}

\sh{nm} lists the symbols provided by a shared library:

\begin{shcode}
$ nm libgazr.so
[...]
000000000002d040 W _ZN4dlib9impl_fhog8init_hogIfNS_33memory_manager_stateless_kernel_1IcEES3_EEvRNS_5arrayINS_7array2dIT_T0_EET1_EEiiii
000000000027e940 b _ZN4dlibL23OBJECT_PART_NOT_PRESENTE
0000000000010d00 t _ZN9__gnu_cxx12__to_xstringINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEcEET_PFiPT0_mPKS8_P13__va_list_tagEmSB_z.constprop.1073
                 U _ZN9_IplImageC1ERKN2cv3MatE
                 U _Znam@@GLIBCXX_3.4
0000000000011370 T _ZNK18HeadPoseEstimation12drawFeaturesERKSt6vectorIS0_IN2cv6Point_IiEESaIS3_EESaIS5_EERNS1_3MatE
0000000000011b80 T _ZNK18HeadPoseEstimation12intersectionEN2cv6Point_IfEES2_S2_S2_RS2_
0000000000011c40 T _ZNK18HeadPoseEstimation4poseEm
0000000000014500 T _ZNK18HeadPoseEstimation5posesEv
0000000000011b30 T _ZNK18HeadPoseEstimation8coordsOfEm14FACIAL_FEATURE
[...]
\end{shcode}

\end{frame}
\begin{frame}[fragile]{Two tools to explore libraries}

C++ signatures returned by \sh{nm} are \textbf{mangled}. You can
demangle them:

\begin{shcode}
$ nm libgazr.so | c++filt
[...]
000000000027e940 b dlib::OBJECT_PART_NOT_PRESENT
0000000000010d00 t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > __gnu_cxx::__to_xstring<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, char>(int (*)(char*, unsigned long, char const*, __va_list_tag*), unsigned long, char const*, ...) [clone .constprop.1073]
                 U _IplImage::_IplImage(cv::Mat const&)
                 U operator new[](unsigned long)@@GLIBCXX_3.4
0000000000011370 T HeadPoseEstimation::drawFeatures(std::vector<std::vector<cv::Point_<int>, std::allocator<cv::Point_<int> > >, std::allocator<std::vector<cv::Point_<int>, std::allocator<cv::Point_<int> > > > > const&, cv::Mat&) const
0000000000011b80 T HeadPoseEstimation::intersection(cv::Point_<float>, cv::Point_<float>, cv::Point_<float>, cv::Point_<float>, cv::Point_<float>&) const
0000000000011c40 T HeadPoseEstimation::pose(unsigned long) const
0000000000014500 T HeadPoseEstimation::poses() const
0000000000011b30 T HeadPoseEstimation::coordsOf(unsigned long, FACIAL_FEATURE) const
[...]
\end{shcode}

\end{frame}
\begin{frame}[fragile]{Two tools to explore libraries}


\sh{ldd} lists the dependencies to shared libraries:

\begin{shcode}
$ ldd estimate_head_pose 
linux-vdso.so.1 (0x00007fff32387000)
libgazr.so (0x00007f3f1822f000)
libopencv_imgcodecs.so.3.2 => /usr/lib/x86_64-linux-gnu/libopencv_imgcodecs.so.3.2 (0x00007f3f17ffa000)
libopencv_core.so.3.2 => /usr/lib/x86_64-linux-gnu/libopencv_core.so.3.2 (0x00007f3f17bbf000)
libdlib.so.18 => /usr/lib/libdlib.so.18 (0x00007f3f178a8000)
libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f3f1751a000)
libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f3f17302000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3f16f11000)
libblas.so.3 => /usr/lib/x86_64-linux-gnu/libblas.so.3 (0x00007f3f16ca4000)
liblapack.so.3 => /usr/lib/x86_64-linux-gnu/liblapack.so.3 (0x00007f3f16406000)
libopencv_calib3d.so.3.2 => /usr/lib/x86_64-linux-gnu/libopencv_calib3d.so.3.2 (0x00007f3f160b6000)
libopencv_imgproc.so.3.2 => /usr/lib/x86_64-linux-gnu/libopencv_imgproc.so.3.2 (0x00007f3f15b65000)
libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f3f157c7000)
[...]
\end{shcode}
\end{frame}

\begin{frame}[fragile]{How to make \& use libraries?}

\begin{onlyenv}<1>

Code source of a pathfinding tool for our robots:

\begin{shcode}
controller.cpp # contains the entry point: int main(...)
ui.cpp
astar.cpp
\end{shcode}

\begin{shcode}
$ g++ controller.cpp ui.cpp astar.cpp -opathfinding_ui
\end{shcode}


\sh{astar.cpp} contains the actual pathfinder, and might be useful for
many other projects. How to turn it into a library?

\end{onlyenv}
\begin{onlyenv}<2>

First, we need to extract the \textbf{API} of our library in a
\textbf{public header} \sh{astar.hpp}:

\begin{cppcode}
#ifndef _PATHFINDING_HPP
#define _PATHFINDING_HPP

#include <tuple>
#include <vector>
#include <array>

const unsigned int MAP_WIDTH = 100;
const unsigned int MAP_HEIGHT = 100;

typedef std::tuple<unsigned int, unsigned int> Position;
typedef std::vector<Position> Path;
typedef std::array<bool, MAP_WIDTH * MAP_HEIGHT> Map;

class AStar {

    AStar(std::shared_ptr<const Map> map);
    Path find(size_t goal_x, size_t goal_y);
}
#endif
\end{cppcode}

The header contains the \textbf{declarations} of our classes, structures,
functions, but not the \textbf{definitions} (the definitions are in
\sh{astar.cpp}).

\end{onlyenv}

\begin{onlyenv}<3>
Next, compile the library:

\begin{shcode}
$ g++ -fPIC -shared astar.cpp -olibastar.so
\end{shcode}
\end{onlyenv}

\begin{onlyenv}<4>
Finally, use it:

\begin{shcode}
$ g++ controller.cpp ui.cpp -lastar -opathfinding_ui
\end{shcode}
\end{onlyenv}


\end{frame}

\begin{frame}[plain]{}
    \begin{center}
        \Large
        {\bf Exercise}: extract the A* algorithm from your C++ {\tt robomaze} client and turn it into a library.
    \end{center}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section[Organising]{Organising your code}

\begin{frame}{}
    \centering

    \highlightbox{\bf principle of least surprise}

    Make people feel at home when they interact with your project!

\end{frame}

\begin{frame}[fragile, label=FHS]{Repository layout}

Try to follow as much as possible the {\bf Filesystem Hierarchy
 Standard} (FHS). Mainly:

\begin{shcode}
src/        # source
include/    # *public* headers
etc/        # configuration files
share/      # data
doc/        # documentation
README
LICENSE
\end{shcode}

\centering

\only<1>{
{\bf NO build artifacts!!}\\
{\bf no binaries} (except possibly in \sh{share/})
}
\only<2>{
\sh{README} (or better, use markdown: \sh{README.md}): what is
the project about? who is the target audience? how to install? how to get started?
}

\end{frame}

\begin{frame}[fragile]{Btw, the Linux filesystem...}

\begin{minted}[frame=none,
               linenos=false,
               fontsize=\tiny,
               xleftmargin=0.5em]{sh}
$ tree -d /
/
├── boot   # linux image, grub, initramfs...
├── dev    # block devices
├── etc    # configuration files
├── home   # users' home directories
├── mnt    # mount point for eg external devices
├── opt    # non-distribution software (eg, ROS)
├── proc   # process information _pseudo-file_ system
├── tmp    # RAM-mounted temporary space
├── usr    # User system resources -- most binaries and lib are here
    ├── bin
    ├── include
    ├── lib
    ├── local
    ├── sbin
    ├── share
    └── src
└── var # variables: log files, local sockets...
\end{minted}

Read more about these here: \href{https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/c23.html}{Linux Filesystem Hierachy}

\end{frame}



\begin{frame}[fragile]{Example 1}

\begin{onlyenv}<1>
What would you change?

\begin{shcode}
my_proj/
  controller.cpp
  ui.cpp
  ui.hpp
  astar.cpp
  astar.hpp
  ui.conf
\end{shcode}

\end{onlyenv}

\begin{onlyenv}<2>
\begin{shcode}
my_proj/
  src/
    controller.cpp
    ui.cpp
    ui.hpp
    astar.cpp
  include/
    astar.hpp
  etc/
    ui.conf
  README.md
  LICENSE
\end{shcode}

\end{onlyenv}

\end{frame}

\begin{frame}[fragile,label=markdown]{README.md example}

\begin{mdcode}
Better pathfinder
=================

![doc/screenshot.png](Screenshot of the provided UI)

This is a really better pathfinder. Check the [publication](http://link...).

Pre-requisites
--------------

- dependency 1
- dependency 2

Installation
------------

```
mkdir build && cd build && cmake .. && make install
```

Usage
-----

...
\end{mdcode}

\end{frame}

\begin{frame}[fragile]{markdown cheat sheet}
\scriptsize

\begin{multicols}{2}

{\bf Titles/sections:}

\begin{mdcode}
Title
=====
Subtitle
--------
### Section
#### Subsection
\end{mdcode}

{\bf Links/images:}

\begin{mdcode}
[Click here](otherpage.md)
![Image caption](myimage.png)
\end{mdcode}

{\bf Formatting:}

\begin{mdcode}
**Bold**
*Italics*
_Underlined_
~~Strike through~~
`code`
\end{mdcode}

{\bf Lists:}

\begin{mdcode}
- item (you can use * or + as well)
- item
- item

1. item
2. item
3. item
\end{mdcode}

{\bf Syntax-highlighted code blocks:}

\begin{mdcode}
```python
    # this is a Python code block
```
\end{mdcode}

\emph{(tables are also possible)}
\end{multicols}

\end{frame}

\begin{frame}[plain]{}
    \begin{center}
        \Large
        {\bf Exercise}: 
        \begin{enumerate}
            \item clone this repo: \sh{git clone https://github.com/severin-lemaignan/robomaze-cpp.git}
            \item re-organise it to follow the FHS and best practises
            \item (bonus) try to compile {\tt astar.cpp} as a shared library
        \end{enumerate}
    \end{center}

\end{frame}

\begin{frame}[fragile]{Example 2: you take over an existing project}


\begin{onlyenv}<1>
\begin{minted}[frame=none,
               linenos=false,
               fontsize=\footnotesize,
               xleftmargin=0.5em]{sh}
joe@doe:/usr/robot-planning$ ls -alh
drwxr-xr-x  2 joe  root    4.0K Sep 22 10:40 .
drwxr-xr-x 12 root root    4.0K Sep 22 10:36 ..
-rwxrwxr-x  1 joe  joe     8.8K Sep 22 10:40 pathfinding_ui
-rw-rw-r--  1 joe  joe     2.1K Sep 22 10:39 compile.sh
-rw-rw-r--  1 joe  joe     1.8K Sep 22 10:39 compile.bat
-rw-rw-r--  1 joe  joe      134 Sep 22 10:39 readme-first.txt
-rw-rw-r--  1 joe  joe      895 Sep 21 21:38 controller.cpp
-rw-rw-r--  1 joe  joe     1.2K Sep 21 20:27 controller.hpp
-rw-rw-r--  1 joe  joe     5.8K Sep 22 10:40 controller.o
-rw-rw-r--  1 joe  joe       50 Sep 19 10:36 controller.ini
-rw-rw-r--  1 joe  joe     2.3K Sep 20 09:31 astar.cpp
-rw-rw-r--  1 joe  joe      230 Sep 20 10:32 astar.hpp
-rw-rw-r--  1 joe  joe     4.3K Sep 22 10:40 astar.o
-rw-rw-r--  1 joe  joe     7.3K Sep 21 10:40 astar.so
-rw-rw-r--  1 joe  joe     6.7K Sep 20 11:13 core.cpp
-rw-rw-r--  1 joe  joe     7.1K Sep 22 10:40 core.o
-rw-rw-r--  1 joe  joe     6.1K Sep 22 10:40 core.a
-rw-rw-r--  1 joe  joe     6.0K Sep 21 16:22 core.lib
\end{minted}

\end{onlyenv}

    \begin{onlyenv}<2>
        Points that can be improved:

        \begin{itemize}
            \item Developping in \texttt{usr/} is a bad practice
            \item Rename files to be more descriptive
            \item Change the layout to follow the FHS (eg \texttt{controller.ini} to
                \texttt{etc/controller.ini})
            \item Use a buildsystem (like CMake) instead of relying on ad-hoc scripts
            \item Add a \texttt{README} and a \texttt{LICENSE}
            \item Public headers should be moved to \texttt{include/}
        \end{itemize}
    \end{onlyenv}
\end{frame}


%\begin{frame}[fragile]{Organising your code: ROS packages}
%
%    When working with ROS, you can use \sh{catkin_create_pkg} to quickly
%    generate a project skeleton + \texttt{CMakeLists.txt}:
%
%\begin{minted}[frame=none,
%               linenos=false,
%               xleftmargin=0.5em]{sh}
%> catkin_create_pkg my_ros_node std_msgs rospy roscpp
%> ls -lh my_ros_node
%-rw-r--r-- 1 joe joe 6.7K Nov 28 15:46 CMakeLists.txt
%drwxr-xr-x 3 joe joe 4.0K Nov 28 15:46 include
%-rw-r--r-- 1 joe joe 2.1K Nov 28 15:46 package.xml
%drwxr-xr-x 2 joe joe 4.0K Nov 28 15:46 src
%\end{minted}
%
%
%\sh{catkin_create_pkg <package_name> [depend1] [depend2] [depend3]}
%\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Build systems}

\begin{frame}[fragile, label=cmake]{Build system}

    Use and provide a build system!

    \begin{itemize}
        \item Windows-only $\Rightarrow$ a Visual Studio solution is ok
        \item MacOS-only $\Rightarrow$ a XCode project is ok
    \end{itemize}

    In all other cases, go for a cross-platform build system like {\bf
    CMake} or {\bf Meson}.

\begin{shcode}
$ sudo apt install cmake
$ sudo apt install cmake-curses-gui # a super useful cmdline GUI for CMake
\end{shcode}


\end{frame}

\begin{frame}[fragile]{Example of a CMake file: CMakeLists.txt}

    Create a file called \texttt{CMakeLists.txt} at the root of the {\tt robomaze-cpp} project:

\begin{minted}[frame=none,
               linenos=false,
               fontsize=\scriptsize,
               xleftmargin=0.5em]{cmake}
cmake_minimum_required(VERSION 3.10)
project(robomaze-pilot VERSION 1.0)

# specify the C++ standard
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED True)

find_package(cpprestsdk REQUIRED) # one external dependency

# First, the library
add_library(astar SHARED src/astar.cpp)
target_include_directories(astar PUBLIC include)

# then, the executable, which depends on the library's target
add_executable(robomaze-client src/controller.cpp)
target_include_directories(robomaze-client PUBLIC include)
target_link_libraries(robomaze-client PUBLIC astar cpprestsdk::cpprest)
\end{minted}

\end{frame}

\begin{frame}[fragile]{Configuring and compiling with CMake}

    \begin{onlyenv}<1>
\begin{shcode}
$ cmake .
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Found ZLIB: /usr/lib/x86_64-linux-gnu/libz.so (found version "1.2.11")
-- Found OpenSSL: /usr/lib/x86_64-linux-gnu/libcrypto.so (found version "1.1.1f")
-- Configuring done
-- Generating done
-- Build files have been written to: robomaze-pilot/build
\end{shcode}
\end{onlyenv}
    \begin{onlyenv}<2>
\begin{shcode}

$ make
Scanning dependencies of target astar
[ 25%] Building CXX object CMakeFiles/astar.dir/src/astar.cpp.o
[ 50%] Linking CXX shared library libastar.so
[ 50%] Built target astar
Scanning dependencies of target robomaze-client
[ 75%] Building CXX object CMakeFiles/robomaze-client.dir/src/controller.cpp.o
[100%] Linking CXX executable robomaze-client
[100%] Built target robomaze-client
$ ls
CMakeCache.txt  CMakeFiles  cmake_install.cmake  CMakeLists.txt  include
    libastar.so  LICENSE  Makefile  README.md  robomaze-client  src
\end{shcode}

    CMake    {\bf configures} the project, and generate {\bf Makefiles} that are
    consumed by {\tt make} to actually compile the project.

\pause

    Note that {\tt make} and Makefiles are independent from CMake. CMake is a
    Makefiles {\bf generator}. It can also generate VS solutions, etc.

\end{onlyenv}
\end{frame}

\begin{frame}[fragile]{Out-of-tree building}

\begin{onlyenv}<1>
\begin{shcode}
robomaze-client/
  src/
    controller.cpp
    astar.cpp
  include/
    astar.hpp
  README.md
  LICENSE
  CMakeLists.txt
\end{shcode}

\end{onlyenv}

\begin{onlyenv}<2>
When compiling the project, create a sub-directory \sh{build} and perform an
    \textbf{out-of-tree} build:

\begin{shcode}
$ mkdir build && cd build
$ cmake ..
$ make
\end{shcode}

\end{onlyenv}

\begin{onlyenv}<3>

\begin{shcode}
robomaze-client/
  build/
    ... # lots of compilation artifacts
  src/
    controller.cpp
    astar.cpp
  include/
    astar.hpp
  README.md
  LICENSE
  CMakeLists.txt
\end{shcode}

    The \sh{build/} directory can be deleted at any point as it contains only
    generated files.
\end{onlyenv}
\end{frame}


\begin{frame}[fragile]{Installing code}

\begin{onlyenv}<1>
Once the application/library is compiled, we normally want to install it in the
    system, to be generally available. CMake can add an {\bf {\tt install}
    target} to the Makefiles:

\begin{cmakecode}
cmake_minimum_required(VERSION 3.10)
project(robomaze-pilot VERSION 1.0)

# [...same code as before...]

# install everything
install(TARGETS astar DESTINATION lib)
install(FILES include/astar.h DESTINATION include)
install(TARGETS robomaze-client DESTINATION bin)
\end{cmakecode}

\end{onlyenv}

\begin{onlyenv}<2>


\begin{shcode}
$ mkdir build && cd build
$ cmake ..
$ make install
Scanning dependencies of target astar
[ 25%] Building CXX object CMakeFiles/astar.dir/src/astar.cpp.o
[ 50%] Linking CXX shared library libastar.so
[ 50%] Built target astar
Scanning dependencies of target robomaze-client
[ 75%] Building CXX object CMakeFiles/robomaze-client.dir/src/controller.cpp.o
[100%] Linking CXX executable robomaze-client
[100%] Built target robomaze-client
Install the project...
-- Install configuration: ""
-- Installing: /usr/local/lib/libastar.so
CMake Error at cmake_install.cmake:47 (file):
  file INSTALL cannot copy file
  "robomaze-pilot/build/libastar.so" to "/usr/local/lib/libastar.so".

Makefile:117: recipe for target 'install' failed
make: *** [install] Error 1
\end{shcode}

\end{onlyenv}
\begin{onlyenv}<3>
\begin{shcode}
$ mkdir build && cd build
$ cmake .. -DCMAKE_INSTALL_PREFIX=$HOME/devel
$ make install
[ 50%] Built target astar
[100%] Built target robomaze-client
Install the project...
-- Install configuration: ""
-- Installing: /home/s-lemaignan/devel/lib/libastar.so
-- Installing: /home/s-lemaignan/devel/include/astar.h
-- Installing: /home/s-lemaignan/devel/bin/robomaze-client
-- Set runtime path of "/home/s-lemaignan/devel/bin/robomaze-client" to ""
\end{shcode}

    Your {\bf install prefix} is where you want to install the code you compile
    yourself. The default ({\tt /usr/local}) is not great {\small (why?)}. I recommend {\tt
    \$HOME/devel} for instance.

\end{onlyenv}
\end{frame}

\begin{frame}[fragile]{The one slide to remember}


\begin{shcode}
$ mkdir build && cd build
$ cmake .. -DCMAKE_INSTALL_PREFIX=$HOME/devel -DCMAKE_BUILD_TYPE=Release
$ make install
\end{shcode}

...you will type that often!
\end{frame}

\begin{frame}[fragile]{What about Python?}

Create a \texttt{setup.py} file at the root of the project:
    \begin{onlyenv}<1>
\begin{pythoncode}
import setuptools

setuptools.setup(
    name="pyrobomaze",
    version="1.0.0",
    author="Séverin Lemaignan",
    author_email="severin.lemaignan@brl.ac.uk",
    description="A A* pathfinder to solve the robomaze game",
    url="https://github.com/severin-lemaignan/pyrobomaze",
    install_requires=['requests'],
    package_dir = {'': 'src'},
    packages=['robomaze'],
    scripts=['scripts/pyrobomaze'],
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    python_requires='>=3.6',
)
\end{pythoncode}

    \end{onlyenv}
    \begin{onlyenv}<2>
\begin{shcode}
$ python3 setup.py install --prefix $HOME/devel
$ pyrobomaze <your robot>
\end{shcode}

        \begin{itemize}
            \item {\tt PYTHONPATH}: where Python looks for libraries
            \item \sh{export PYTHONPATH=$HOME/devel/lib/python3.7/site-package} (add to your {\tt .bashrc})
            \item why no need for {\tt python3} in front of {\tt pyrobomaze}? $\Rightarrow$ shebang: {\tt #! /usr/bin/python3}
              
        \end{itemize}



    \end{onlyenv}

\end{frame}

\begin{frame}[plain]{}
    \begin{center}
        \Large
        {\bf Exercise}: 
        \begin{enumerate}
            \item clone this repo: \sh{git clone https://github.com/severin-lemaignan/pyrobomaze.git}
            \item re-organise it to follow the FHS and best practises
            \item add a setup.py and install the python project locally
        \end{enumerate}
    \end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Versioning}
\begin{frame}[label=versioning]{Semantic versioning}
    \only<1>{
    Given a version number \texttt{MAJOR.MINOR.PATCH}, increment the:

    \begin{itemize}
        \item \texttt{MAJOR} version when you make incompatible API changes,
        \item \texttt{MINOR} version when you add functionality in a backwards-compatible
manner, and
        \item \texttt{PATCH} version when you make backwards-compatible bug fixes.
    \end{itemize}

Additional labels for pre-release and build metadata are
    available as extensions to the \texttt{MAJOR.MINOR.PATCH format}.

    \source{semver.org}{\texttt{semver} website}

}

    \only<2->{

        You are the maintainer of \texttt{cool\_app}, that depends on OpenCV
        \texttt{2.4.11}.

        The OpenCV project releases a new version, what should you do...

        \begin{itemize}
            \item <2-> ...if the new version is \texttt{2.4.12}?
            \item <3-> ...if the new version is \texttt{2.5.0}?
            \item <4-> ...if the new version is \texttt{2.9.0}?
            \item <5-> ...if the new version is \texttt{3.0.0-beta}?
            \item <6-> ...if the new version is \texttt{3.0.0}?
        \end{itemize}
    }
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section[Licenses]{Software Licenses, Open-source, free software}

\begin{frame}[label=licenses]{Software licenses}
    \begin{itemize}
        \item<+-> {\bf no license} $\Rightarrow$ default copyright laws apply.
            You retain all rights to your source code; nobody else may
            reproduce, distribute, or create derivative works from your work.
        \item<+-> {\bf Permissive licenses}: others do essentially whatever they
            want with your code, as long as they give your attribution.
            Examples: MIT, BSD
        \item<+-> {\bf Copyleft licenses}: Derivative work must be made
            available under the same terms as the original work (\emph{viral
            licenses}). Example: GPL
    \end{itemize}

    \only<1-3>{
    \begin{center}
        \includegraphics[width=0.2\paperheight]{osi}\hspace{1em}
        \includegraphics[width=0.2\paperheight]{GPLv3}
    \end{center}
    }

    \centering
    \only<4>{
        {\bf If you are paid by UWE or UoB, the copyright belongs to the uni.}
    }

    \only<5>{
    Check \url{http://choosealicense.com/}
    }


\end{frame}

\begin{frame}{What if you want to use a GPL library?}
    There is a legal dispute to know whether merely \emph{linking} with a
    library result in a \emph{derivative work} (which would then have to be
    licensed as GPL).

    \pause

    The LGPL (\emph{Lesser GPL}) explicitely allows the usage of the library
    without putting restrictions on the licensing of the resulting executable.

\end{frame}

\begin{frame}{}

    \begin{exampleblock}{Open-source vs Free software?}
    ``When we call software "free," we mean that it respects the users' essential
    freedoms: the freedom to run it, to study and change it, and to redistribute
    copies with or without changes. This is a matter of freedom, not price, so
    think of "free speech," not "free beer."''

        \vspace{1em}
    ``Open source is a development methodology; free software is a social
        movement''

    \end{exampleblock}

    \source{https://www.gnu.org/philosophy/open-source-misses-the-point.en.html}{GNU
    website}
\end{frame}

\section{Packaging}

\begin{frame}[fragile,label=deb]{Investigating the \texttt{hello} package}
    \begin{onlyenv}<1>

\begin{shcode}
$ sudo apt install hello
$ hello
Hello, world!
\end{shcode}

    What \emph{really} happens when we type \sh{apt install hello}?

    \end{onlyenv}
    \begin{onlyenv}<2>

    The \texttt{hello} package is downloaded from the Ubuntu repositories, and
    installed. Let's investigate:

\begin{shcode}
$ apt download hello
$ ar x hello_2.10-1build1_amd64.deb
$ ls
control.tar.gz  data.tar.xz  debian-binary
\end{shcode}

    \end{onlyenv}
    \begin{onlyenv}<3>


\begin{shcode}
$ tar xf control.tar.gz
$ cat control
Package: hello
Version: 2.10-1build1
Architecture: amd64
Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>
Original-Maintainer: Santiago Vila <sanvila@debian.org>
Installed-Size: 108
Depends: libc6 (>= 2.14)
Conflicts: hello-traditional
Breaks: hello-debhelper (<< 2.9)
Replaces: hello-debhelper (<< 2.9), hello-traditional
Section: devel
Priority: optional
Homepage: http://www.gnu.org/software/hello/
Description: example package based on GNU hello
 The GNU hello program produces a familiar, friendly greeting.  It
 allows non-programmers to use a classic computer science tool which
 would otherwise be unavailable to them.
 .
 Seriously, though: this is an example of how to do a Debian package.
 It is the Debian version of the GNU Project's `hello world' program
 (which is itself an example for the GNU Project).
\end{shcode}

    \end{onlyenv}
\end{frame}

\begin{frame}[fragile]{Dependency resolution}

Applications depends on other bits of code! Other libraries, resources,
executables, etc.

The package has to store in its metadata this information.

The \emph{dependency solver} (on Ubuntu/Debian, \texttt{apt}) finds the
smaller set of packages to install to satisfy all dependencies.

\pause

\begin{shcode}
$ debtree firefox > firefox_deps.dot
$ dot -Tsvg -ofirefox_deps.svg firefox_deps.dot
\end{shcode}

\end{frame}

\imageframe{firefox}

\begin{frame}{Creating a package}
    Creating packages is not trivial, and necessitate a good knowledge of the
    inner working of a application or library.

    \pause

    The build system (CMake, for instance) already knows a lot!

\end{frame}

\begin{frame}[fragile]{cpack}
\begin{onlyenv}<1>
    Using \texttt{cpack} to create a package for your A* pathfinder:

\begin{minted}[frame=none,
               linenos=false,
               fontsize=\scriptsize,
               xleftmargin=0.5em]{cmake}
cmake_minimum_required(VERSION 3.10)

project(robomaze-pilot VERSION 1.0)

set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE")
set(CPACK_PACKAGE_VERSION_MAJOR "${robomaze-pilot_VERSION_MAJOR}")
set(CPACK_PACKAGE_VERSION_MINOR "${robomaze-pilot_VERSION_MINOR}")
set(CPACK_PACKAGE_CONTACT "Séverin Lemaignan <severin.lemaignan@brl.ac.uk>")
include(CPack)

# remaining of the file is identical
\end{minted}

Then:

\begin{minted}[frame=none,
               linenos=false,
               fontsize=\scriptsize,
               xleftmargin=0.5em]{sh}
$ cpack ..
$ ls *.deb
robomaze-pilot-1.0.1-Linux.deb
$ sudo apt install ./robomaze-pilot-1.0.1-Linux.deb
\end{minted}
    \end{onlyenv}
    \begin{onlyenv}<2>

        (what about the install prefix?)

\begin{shcode}
$ dpkg -L robomaze-pilot
/usr
/usr/bin
/usr/bin/robomaze-client
/usr/include
/usr/include/astar.h
/usr/lib
/usr/lib/libastar.so
\end{shcode}

$\rightarrow$ The install prefix is automatically replaced to the system prefix.
    \end{onlyenv}

\end{frame}

\begin{frame}[fragile]{What about Python packaging?}

    Simpler:

\begin{shcode}
$ python3 setup.py sdist bdist_wheel
\end{shcode}

This command should output a lot of text and once completed should generate two files in the dist directory:

\begin{shcode}
dist/
  pyrobomaze-1.0.0-py3-none-any.whl
  pyrobomaze-1.0.0.tar.gz
\end{shcode}

    You need to create an account on the \emph{Python Index} (\url{pypi.org}).
    Then you can upload your package:

\begin{shcode}
$ twine upload dist/*
\end{shcode}

That's it! The whole world can access your package.


\end{frame}

\imageframe[color=black]{pypi-dialogs}

\begin{frame}[fragile]{Language-specific package management}

    How to use our package? {\bf Anyone} can simply type:

\begin{shcode}
$ pip3 install pyrobomaze
$ pyrobomaze my_robot
\end{shcode}

    $\rightarrow$ Anyone can upload Python packages to the {\bf pypi} archive: great to
    quickly share software packages, without having to bother with source code.

\pause

    Many languages offer such a language-specific package management system
    ({\bf npm} for Javascript, {\bf cargo} for rust, {\bf rubygems} for ruby,
    etc)

\pause

    However, no guarantees! In contrast, the acceptance process for Debian is
    extremly strict $\rightarrow$ guarantees a level of quality and proper
    integration.

\end{frame}

\section[Sharing]{Advanced git}

\begin{frame}[label=advancedgit]{Advanced git}
    \begin{itemize}
        \item collaborating
        \item conflict resolution
        \item branching
    \end{itemize}
\end{frame}

\imageframe{dvcs-1}
\imageframe{dvcs-2}
\imageframe{dvcs-3}
\imageframe{dvcs-4}
\imageframe{dvcs-5}
\imageframe{dvcs-6}
\imageframe{dvcs-7}
\imageframe{dvcs-8}



\begin{frame}[fragile]{}

\centering

    \begin{tikzpicture}
    % Commit DAG
    \onslide<1-3>{
      \gitDAG[grow right sep = 2em]{
        A -- B -- C;
      };

      % Branch
      \gitbranch
        {master}     % node name and text 
        {above=of C} % node placement
        {C}          % target
    }



      % HEAD reference
    \onslide<1-2>{
      \gitHEAD
        {above=of master} % node placement
        {master}          % target
    }

    \onslide<3>{
      \gitremotebranch
        [origmaster]    % node name
        {origin/master} % node text
        {above=of master}    % node placement
        {master}             % target
      \gitHEAD
        {above=of origmaster} % node placement
        {origmaster}          % target
    }

    \end{tikzpicture}

\vspace{3em}
    \begin{overlayarea}{\textwidth}{5cm}
\only<2>{
\small
\texttt{git remote add origin git@github.com:user/repo.git}\par
\scriptsize
\texttt{git remote add john-usb E:\textbackslash john\_repo}\\
\texttt{git remote add ftp-origin ftp://host.xz/path/to/repo.git/}\\
...\\
}

\only<3>{
\Large
\texttt{git push origin master} \par
\normalsize
(or simply \texttt{git push})
}
\end{overlayarea}
\end{frame}

\begin{frame}[fragile]{}

    \centering

    \begin{tikzpicture}
        \onslide<1-2>{
            \gitDAG[grow right sep = 2em]{
                A -- B -- C -- D -- E;
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of E} % node placement
            {E}          % target

            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target

            \gitremotebranch
            [origmaster]    % node name
            {origin/master} % node text
            {above=of C}    % node placement
            {C}             % target
        }

        \onslide<3>{
            \gitDAG[grow right sep = 2em]{
                A -- B -- C -- {
                    F,
                    D -- E,
                }
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of E} % node placement
            {E}          % target

            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target

            \gitremotebranch
            [origmaster]    % node name
            {origin/master} % node text
            {above=of F}    % node placement
            {F}             % target
        }

        \onslide<4-5>{
            \gitDAG[grow right sep = 2em]{
                A -- B -- C -- {
                    F -- D' -- E',
                    {[nodes=unreachable] D -- E },
                }
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of E'} % node placement
            {E'}          % target

            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target

            \gitremotebranch
            [origmaster]    % node name
            {origin/master} % node text
            {above=of F}    % node placement
            {F}             % target
        }

        \onslide<6->{
            \gitDAG[grow right sep = 2em]{
                A -- B -- C -- {
                    F -- D' -- E',
                    {[nodes=unreachable] D -- E },
                }
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of E'} % node placement
            {E'}          % target


            \gitremotebranch
            [origmaster]    % node name
            {origin/master} % node text
            {above=of master}    % node placement
            {master}             % target

            \gitHEAD
            {above=of origmaster} % node placement
            {origmaster}          % target
        }


    \end{tikzpicture}

    \vspace{3em}
    \begin{overlayarea}{\textwidth}{5cm}
    \only<2>{
        What happened on our remote? Let's have a look...\\
        \Large
        \texttt{git fetch origin}\\
    }

    \only<4>{
        \Large
        \texttt{git rebase origin/master}\par
        \normalsize
        (but you don't need it, because...)\\
    }
    \only<5>{
        \Large
        \texttt{git pull --rebase}\\
    }
    \only<6>{
        \Large
        \texttt{git push}\\
    }
    \end{overlayarea}

\end{frame}



\begin{frame}[fragile]{To summarize...}

The first time...
\begin{shcode}
$ git clone <url>
# for instance,
# git clone https://github.com/user/repo.git
\end{shcode}
Then...
\begin{shcode}
$ cd <repo>
# make some changes...
$ git add <files>
$ git commit -m"<commit message>"
# ...
# when you want to share:
$ git pull --rebase # any changes on the remote?
$ git push
\end{shcode}

\end{frame}

\section[Conflicts]{The dreadful conflicts}

\begin{frame}[fragile]{The dreadful conflict}

    While peacefully editing your last (great) report...

\begin{shcode}
$ git pull --rebase john master
First, rewinding head to replay your work on top of it...
Applying: Better terminology
Using index info to reconstruct a base tree...
M	controller.tex
Falling back to patching base and 3-way merge...
Auto-merging controller.tex
CONFLICT (content): Merge conflict in controller.tex
error: Failed to merge in the changes.
Patch failed at 0001 Better terminology
The copy of the patch that failed is found in: .git/rebase-apply/patch

When you have resolved this problem, run "git rebase --continue".
If you prefer to skip this patch, run "git rebase --skip" instead.
To check out the original branch and stop rebasing, run "git rebase --abort".
\end{shcode}
\end{frame}

\begin{frame}[fragile]{}

    \begin{exampleblock}{A conflict happens when two modifications of a given
    file overlap}
    Two persons can modify the same file at the same time, as
    long as they do not work on the same region of the file.
    \end{exampleblock}


\begin{shcode}
$ git pull --rebase john master
# conflict!
$ git mergetool
\end{shcode}
\end{frame}

\imageframe[color=black,caption=Meld is one of the nice tools to fix conflicts]{meld}

\section[Going social]{Social coding: GitHub workflow}

\imageframe[caption=GitHub,color=black]{github-morse}
\imageframe[caption=BitBucket,color=black]{bitbucket}
\imageframe[caption=GitLab -- open-source You can install it on your own server,color=black]{gitlab}

\imageframe[color=black]{github-morse}

\imageframe{github-workflow-1}
\imageframe{github-workflow-2}
\imageframe{github-workflow-3}
\imageframe{github-workflow-4}
\imageframe{github-workflow-5}
\imageframe{github-workflow-6}


\begin{frame}[fragile]{What happened exactly?}

    \vspace{1em}
    \centering

    \begin{multicols}{2}
        \resizebox{\columnwidth}{!}{%
    \begin{tikzpicture}
        \onslide<1>{
            \gitDAG[grow right sep = 2em]{
                A -- B -- C -- D -- E;
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of E} % node placement
            {E}          % target

            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target

            \gitremotebranch
            [origmaster]    % node name
            {origin/master} % node text
            {above=of C}    % node placement
            {C}             % target
        }

        \onslide<2>{
            \gitDAG[grow right sep = 2em]{
                A -- B -- C -- {
                    F,
                    D -- E,
                }
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of E} % node placement
            {E}          % target

            \gitremotebranch
            [johnmaster]    % node name
            {john/master} % node text
            {above=1.2 of F}    % node placement
            {F}             % target


            \gitremotebranch
            [origmaster]    % node name
            {origin/master} % node text
            {above=of C}    % node placement
            {C}             % target

            \gitHEAD
            {above=of master} % node placement
            {master}          % target

        }

        \onslide<3>{
            \gitDAG[grow right sep = 2em]{
                A -- B -- C -- {
                    F -- D' -- E',
                    {[nodes=unreachable] D -- E },
                }
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of E'} % node placement
            {E'}          % target

            \gitremotebranch
            [origmaster]    % node name
            {origin/master} % node text
            {above=of C}    % node placement
            {C}             % target

            \gitremotebranch
            [johnmaster]    % node name
            {john/master} % node text
            {above=1.2 of F}    % node placement
            {F}             % target


            \gitHEAD
            {above=of master} % node placement
            {master}          % target


        }
        \onslide<4>{
            \gitDAG[grow right sep = 2em]{
                A -- B -- C -- {
                    F -- D' -- E',
                    {[nodes=unreachable] D -- E },
                }
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of E'} % node placement
            {E'}          % target

            \gitremotebranch
            [origmaster]    % node name
            {origin/master} % node text
            {above=of master}    % node placement
            {master}             % target

            \gitremotebranch
            [johnmaster]    % node name
            {john/master} % node text
            {above=1.2 of F}    % node placement
            {F}             % target


            \gitHEAD
            {above=of origmaster} % node placement
            {origmaster}          % target


        }

    \end{tikzpicture}
    }

    \only<1>{
        \includegraphics[width=0.8\columnwidth]{github-workflow-details-3}
    }
    \only<2-3>{
        \includegraphics[width=0.8\columnwidth]{github-workflow-details-5}
    }

    \only<4>{
        \includegraphics[width=0.8\columnwidth]{github-workflow-details-6}
    }

    \end{multicols}

    \begin{overlayarea}{\textwidth}{5cm}
    \only<1>{
        After forking on GitHub, Paul runs\\
        \texttt{git clone https://github.com/paul/cool\_app.git}\\
        \normalsize
        and he adds few local commits\\
    }

    \only<2>{
        He would like to propose his changes to John\\
        First, he needs to get the latest changes from John:\par
        \footnotesize
        \texttt{git add remote john https://github.com/john/cool\_app.git}\\
        \normalsize
        \texttt{git fetch john}\\
    }

    \only<3>{
        Paul rebases his \texttt{master} branch on John's one:\par
        \texttt{git rebase john/master}\par
        \footnotesize
        (actually, Paul would simply run \texttt{git pull --rebase john master})
    }
    \only<4>{
        He pushes his commits to his own GitHub account:\par
        \texttt{git push}\\
        ...and finally press the ``Create a pull request'' button in GitHub.
    }

\end{overlayarea}
\end{frame}

\begin{frame}{}
    \centering
    (what happens next on John's side is a story for another day :-) But to make
    it short, he can press ``Merge pull request'' on his GitHub account if he is
    happy with the pull-request!)
\end{frame}
\imageframe{github-workflow-7}

\begin{frame}{GitLab@BRL}

    We have our own 'GitHub': \url{git.brl.ac.uk}

    If you can not yet login, drop an email to \url{itonline@uwe.ac.uk} and ask
    for access.

\end{frame}

\imageframe[caption=GitLab@BRL,color=black]{gitlab-dashboard}
\imageframe[caption=GitLab@BRL,color=black]{gitlab-project}

\begin{frame}{Commit hygiene}
    \centering

    {\bf ``Show me the project history, I'll tell you what coder you are''}

    \begin{itemize}
        \item<1> {\bf Commit often!} Push when needed (or at the end of day)
        \item<2> Write useful messages (no ``\texttt{Fixed bug}'' or ``\texttt{New
            file}'')
        \item<2> First line of commit messages < 72 characters
        \item<3> Tag important commits!
    \end{itemize}

    \only<1>{
        Because commits are local (ie, private), {\bf do commit often}:
        {\bf mistakes are ok} as you can fix them before sharing with others.
    }
    \only<3>{
        Notably, GitHub (amongst others) interpret tags as {\bf releases} of
        your code.
    }
\end{frame}

\begin{frame}{}
    \centering
    \highlightbox{one repo = one thing}

    make plenty of repos!
\end{frame}

\section{Working with branches}

\begin{frame}{Branches}

    \centering

    \begin{tikzpicture}
        \only<1-5>{
        \onslide<1>{
            \gitDAG[grow right sep = 2em]{
                A -- B -- C;
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of C} % node placement
            {C}          % target

            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target

        }

        \onslide<2>{
            \gitDAG[grow right sep = 2em]{
                A -- B -- C;
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of C} % node placement
            {C}          % target

            \gitbranch
            {cool-idea}     % node name and text 
            {above=of master} % node placement
            {master}          % target

            % HEAD reference
            \gitHEAD
            {above=of cool-idea} % node placement
            {cool-idea}          % target
        }

        \onslide<3>{
            \gitDAG[grow right sep = 2em]{
                A -- B -- C -- D -- E;
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of C} % node placement
            {C}          % target

            \gitbranch
            {cool-idea}     % node name and text 
            {above=of E} % node placement
            {E}          % target

            % HEAD reference
            \gitHEAD
            {above=of cool-idea} % node placement
            {cool-idea}          % target
        }

        \onslide<4>{
            \gitDAG[grow right sep = 2em]{
                A -- B -- C -- D -- E;
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of C} % node placement
            {C}          % target

            \gitbranch
            {cool-idea}     % node name and text 
            {above=of E} % node placement
            {E}          % target

            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target
        }

        \onslide<5>{
            \gitDAG[grow right sep = 2em]{
                A -- B -- C -- {
                    D -- E,
                    F -- G -- H,
                }
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of H} % node placement
            {H}          % target

            \gitbranch
            {cool-idea}     % node name and text 
            {above=of E} % node placement
            {E}          % target

            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target
        }
    }
        \only<6->{
            \gitDAG[grow right sep = 1.5em]{
                A -- B -- C -- {
                    D -- E,
                    F -- G -- H -- {
                        K,
                        I -- J
                        },
                }
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of K} % node placement
            {K}          % target

            \gitbranch
            {cool-idea}     % node name and text 
            {above=of E} % node placement
            {E}          % target

            \gitbranch
            {bug142}     % node name and text 
            {above=of J} % node placement
            {J}          % target


            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target
        }


    \end{tikzpicture}

    \vspace{3em}
    \centering
    \only<1>{
        What if...?\\
    }
    \only<2>{
        \Large
        \texttt{git checkout -b cool-idea}\\
    }
    \only<5>{
        The branch name is an alias for the tip of the current branch\\
    }
    \only<6>{
        $\Rightarrow$ branches are very cheap\\ 
        +10 of them at a given time it not uncommon\\
    }
    \uncover<4>{
        Let go back to serious stuff!\\
        \Large
        \texttt{git checkout master}
    }


\end{frame}


\begin{frame}{Merging branches}

    \centering

\begin{tikzpicture}[
    >=latex,
    every edge/.style={draw,thick,hriSec3}
]

        \onslide<1>{
            \gitDAG[grow right sep = 2em]{
                B -- C -- {
                    D -- E,
                    F -- G -- H,
                };
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of H} % node placement
            {H}          % target

            \gitbranch
            {cool-idea}     % node name and text 
            {above=of E} % node placement
            {E}          % target

            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target

            \node[DAGcommit,right=3 of E.south,dashed] (merge) {?};
            \path[draw] (E) edge [->, bend left] (merge);
            \path[draw] (H) edge [->, bend right] (merge);
    }
        \onslide<2>{
            \gitDAG[grow right sep = 2em]{
                B -- C -- {
                    D -- E,
                    F -- G -- H -- merge,
                };

                E -- merge;
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of merge} % node placement
            {merge}          % target

            \gitbranch
            {cool-idea}     % node name and text 
            {above=of E} % node placement
            {E}          % target

            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target

    }
        \onslide<3>{
            \gitDAG[grow right sep = 2em]{
                B -- C -- {
                    D -- E,
                    F -- G -- H -- I -- J,
                };

                E -- I;
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of J} % node placement
            {J}          % target

            \gitbranch
            {cool-idea}     % node name and text 
            {above=of E} % node placement
            {E}          % target

            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target

    }
        \onslide<4>{
            \gitDAG[grow right sep = 2em]{
                B -- C -- {
                    D -- E -- K -- L,
                    F -- G -- H -- I -- J,
                };

                E -- I;
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of J} % node placement
            {J}          % target

            \gitbranch
            {cool-idea}     % node name and text 
            {above=of L} % node placement
            {L}          % target

            % HEAD reference
            \gitHEAD
            {above=of cool-idea} % node placement
            {cool-idea}          % target

    }



    \end{tikzpicture}

    \vspace{3em}
    \centering
    \only<1>{
        Two options: {\bf merging} and {\bf rebasing}\\
    }
    \only<2>{
        Merging\\
        \Large
        \texttt{git merge cool-idea}\\
    }
    \only<3>{
        \Large
        \texttt{git commit}\\
    }
    \uncover<4>{
        \Large
        \texttt{git checkout cool-idea}\\
        \texttt{git commit}\\
        \normalsize
        ...etc.
    }


\end{frame}

\begin{frame}{Rebasing branches}

    \centering

\begin{tikzpicture}[
    >=latex,
    every edge/.style={draw,thick,hriSec3}
]

        \onslide<1>{
            \gitDAG[grow right sep = 2em]{
                B -- C -- {
                    D -- E,
                    F -- G -- H,
                };
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of H} % node placement
            {H}          % target

            \gitbranch
            {cool-idea}     % node name and text 
            {above=of E} % node placement
            {E}          % target

            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target

            \node[DAGcommit,right=3 of E.south,dashed] (merge) {?};
            \path[draw] (E) edge [->, bend left] (merge);
            \path[draw] (H) edge [->, bend right] (merge);
    }
        \onslide<2>{
            \gitDAG[grow right sep = 2em]{
                B -- C -- {
                    D -- E -- F' -- G' -- H',
                    {[nodes=unreachable] F -- G -- H },
                };
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of H'} % node placement
            {H'}          % target

            \gitbranch
            {cool-idea}     % node name and text 
            {above=of E} % node placement
            {E}          % target

            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target

    }
        \onslide<3>{
            \gitDAG[grow right sep = 2em]{
                B -- C -- {
                    D -- E -- {
                        I -- J,
                        F' -- G' -- H',
                    },
                    {[nodes=unreachable] F -- G -- H },
                };
            };

            % Branch
            \gitbranch
            {master}     % node name and text 
            {above=of H'} % node placement
            {H'}          % target

            \gitbranch
            {cool-idea}     % node name and text 
            {above=of J} % node placement
            {J}          % target

            % HEAD reference
            \gitHEAD
            {above=of cool-idea} % node placement
            {cool-idea}          % target

    }

    \end{tikzpicture}

    \vspace{3em}
    \centering
    \only<2>{
        Rebasing\\
        \Large
        \texttt{git rebase cool-idea}\\
    }
    \uncover<3>{
        \Large
        \texttt{git checkout cool-idea}\\
        \texttt{git commit}\\
    }


\end{frame}

\begin{frame}{More commit aliases: Tags}

    \centering

    \begin{tikzpicture}
            \gitDAG[grow right sep = 1.5em]{
                A -- B -- C -- {
                    D -- E,
                    F -- G -- H -- {
                        K,
                        I -- J
                        },
                }
            };

            \gittag
            [v12]
            {v1.2}
            {above=of C}
            {C}

            \gitbranch
            {master}
            {above=of K}
            {K}

            \gitbranch
            {cool-idea}
            {above=of E}
            {E}

            \gitbranch
            {bug142}
            {above=of J}
            {J}

            \gittag
            {WP5}
            {above=of H}
            {H}


            % HEAD reference
            \gitHEAD
            {above=of master} % node placement
            {master}          % target


    \end{tikzpicture}

    \vspace{3em}
    \centering
        {\bf Label} important commits/milestones\\
        \Large
        \texttt{git tag v1.2}\\
        \texttt{git tag WP5}


\end{frame}



\begin{frame}[fragile]{To summarize...}

\begin{shcode}
# where are we?
$ git branch
master
# make some changes...
$ git add <files> && git commit -m"<commit message>"
# start working on something new?
$ git checkout -b new-idea
$ git branch
new-idea
# work in that branch for a while
$ git add <files> && git commit -m"<commit message>"
# back to master
$ git checkout master
#...
# rebase master on new-idea: new-idea is now in master
$ git rebase new-idea
\end{shcode}

\end{frame}

\section[Summary]{The one slide to remember}

\begin{frame}{GIT cheat sheet}
\scriptsize
    \begin{multicols}{2}

    {\bf To start...}\\
    ...from scratch: \texttt{git init}\\
    ...from existing repo: \texttt{git clone <url>}\par

    \rule{\columnwidth}{0.2pt}

    {\bf Prepare commits:}\\
    \texttt{git add}\\
    \texttt{git rm}\\
    \texttt{git add -p} (partial files)\par

    {\bf Commit:}\\
    \texttt{git commit}\par

    \rule{\columnwidth}{0.2pt}

    {\bf Create branch:}\\
    \texttt{git checkout -b <branch>}\par

    {\bf Jump between branches:}\\
    \texttt{git checkout <branch>}\par

    {\bf ``Import'' another branch:}\\
    \texttt{git rebase <other\_branch>}\par

    \rule{\columnwidth}{0.2pt}

    {\bf Add a remote source:}\\
    \texttt{git remote add <name> <url>}\par

    {\bf What's new on a remote?}\\
    \texttt{git pull <remote> <branch>}\\
    {\tiny (\texttt{git pull} alone $\equiv$ \texttt{git pull origin master})}\par

    {\bf Share stuff on a remote:}\\
    \texttt{git push <remote> <branch>}\\
    {\tiny (\texttt{git push} alone $\equiv$ \texttt{git push origin master})}\par

    \rule{\columnwidth}{0.2pt}

    \begin{multicols}{2}
    {\bf Repo state}\\
    \texttt{git status}\par

    {\bf Repo history}\\
    \texttt{git log}\par

    {\bf Who did what?}\\
    \texttt{git blame}\par

    {\bf I've lost everythg!}\\
    \texttt{git reflog}\par


    \end{multicols}

    ~\\

    \end{multicols}

\end{frame}

\begin{frame}{A few cool GitHub stuff to finish}
    Besides bugtracking, project homepages and wikis,GitHub integrates with many
    third-party services \& tools:

    \begin{itemize}
        \item {\bf Travis CI} or {\bf AppVeyor} for continuous integration
    \end{itemize}
\end{frame}

\imageframe{pr-failed-ci}

\begin{frame}{A few cool stuff to finish}
    + GitHub integrates with many external services 
    \& tools:

    \begin{itemize}
        \item {\bf Travis CI} or {\bf AppVeyor} for continuous integration
        \item {\bf zenodo}: associate a DOI to your repository
        \item {\bf ReadTheDocs}: generate and publish on-line 
            documentation
    \end{itemize}
\end{frame}





\begin{frame}{}
    \begin{center}
        \Large
        That's all for today, folks!\\[2em]
    \end{center}

        \vspace{10em}

        Slides:\\
        \href{https://github.com/severin-lemaignan/lecture-software-engineering}{\small
        github.com/severin-lemaignan/lecture-software-engineering}


\end{frame}

\begin{frame}{Additional material}

    \begin{itemize}
        \item \hyperlink{gitgui}{git from a GUI}
    \end{itemize}
\end{frame}

\begin{frame}[label=gitgui]{}
    \centering
    Viewed from a GUI (macOS \& Windows)\\
    {\bf GitHub Desktop} Walkthrough\par
    \vspace{3em}
    \url{https://desktop.github.com/}
\end{frame}

\imageframe[caption=Log in to your GitHub account,color=black]{github-windows/1}
\imageframe[caption=Create a (local) repository,color=black]{github-windows/2}
\imageframe[caption=GitHub Desktop has already made a first commit on your behalf,color=black]{github-windows/3}
\imageframe[caption=Open the repo in Windows Explorer,color=black]{github-windows/4}
\imageframe[caption=Add a simple README.md...,color=black]{github-windows/5}
\imageframe[caption=The change is listed in the Changes panel,color=black]{github-windows/6}
\imageframe[caption=Write a commit message \& commit!,color=black]{github-windows/7}
\imageframe[caption=The History panel shows the log and a diff of your changes,color=black]{github-windows/8}

\begin{frame}{}
    Viewed from a GUI\\
    {\bf Tortoise GIT}\par
    \vspace{3em}
    \url{https://tortoisegit.org/}
\end{frame}

\imageframe[color=black,caption=Direct interaction in the Windows explorer]{tortoise-git/gitcommit}
\imageframe[color=black,caption=Files' status appear as icons]{tortoise-git/overlays}
\imageframe[color=black,caption=All the functionalities are available]{tortoise-git/contextmenu}
\imageframe[color=black,caption=Commit window]{tortoise-git/commit}

\begin{frame}{}
    \centering
    {Git branches viewed from a GUI...}
\end{frame}

\imageframe[caption=We can easily create a new branch,color=black]{github-windows/9}
\imageframe[caption=We can compare numerical\_coordinates with master (click on View branch for the full history),color=black]{github-windows/10}
\imageframe[caption=We can jump between branches...,color=black]{github-windows/11}
\imageframe[caption=...and watch how they diverge,color=black]{github-windows/12}
\imageframe[caption=We switch back to numerical\_coordinates and merge in master,color=black]{github-windows/13}
\imageframe[caption=The merge commit is reflected in the history of the branch,color=black]{github-windows/14}


\end{document}
